## Капля истории
История, каким был веб до сборщиков...

## Рассказать про сокращения в `npm`:
`npm i -S/-D/-g -E`

## Для самого начала
Для начала, что такое модуль? Модуль - механизм JS для разделения кода на небольшие самостоятельные части.
Модульность обеспечивает поддержку изоляции кода.
Какие были проблемы и зачем нужно? Если знать, что JS не разрабатывался, чтобы стать таким популярным и востребованным, то все сразу встанет на свои места
- раньше было мало JS кода, поэтому было ок, прикреплять сторонние скрипты, которые общались через глобальную область window
  - но: количество скриптов увеличилось, один мог сломать другой (коллизия имен). Еще раз: один скрипт мог "общаться" с другим только через window, путем объявления `var`-переменных
  - но: целая куча кода в одном месте
  - но: ручками прописываем все скрипты через `<script>`
- не использовались так повсеместно различные библиотеки


Раньше в JS не было этой возможности по умолчанию, появилась только в стандарте JS 2015 года. Поэтому появились библиотеки для динамической подгрузки модулей:
- AMD (Asynchronous Module definition)
- require.js
- CommonJs (для сервера Node.Js. Использует синтаксис `require` и `module.exports`. Важно, что это не являлось ключевыми словами языка, а просто оберткой над объектами, куда заворачивались все модули)
- UMD (универсальная, совместима с AMD и CommonJs)
- ![img_1.png](img_1.png)
<br>

Это очень сокращенный список, JS прошел через целую кучу вариантов реализации модульности (от использования паттернов и соглашений по разделению скриптов, до всяких-разных велосипедов. И наконец - стандарт)
Кому интересно, [могут почитать](https://habr.com/ru/company/yandex/blog/192874/). Более подробно есть целая [книга](https://www.patterns.dev/posts/classic-design-patterns/)
<br>
[Сам сайт супер полезен для изучения паттернов.](https://www.patterns.dev/)
<br>

**Важно!** В Node.js (common.js модуль) используется `require` для импорта вместо `import`, а браузеры его не знают! Это тема именно из node.js.
(показать пример компиляции) (ts в разные виды модулей)
Модули используют синтаксис `export` и `import`.
```JS
// any other module uses square.js
import { name, draw, reportArea, reportPerimeter } from './modules/square.js';

// square.js
export const name = 'square';

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return {
    length: length,
    x: x,
    y: y,
    color: color
  };
}
```

Чтобы притащить такой скрипт в HTML, необходимо сообщить, что он является модулем. `<script type="module" src="main.js"></script>`<br>
Какие есть еще отличия от обычного JS?
1. нельзя запустить локально HTML, только на сервере. Иначе будет CORS-ошибка (Cross-origin resource sharing - предотвращает запросы с "левых" доменов)
2. JS исполняется сразу в строгом режиме (директива "use strict")
3. скрипт является `defer` по умолчанию
4. скрипты запускаются 1 раз (**если у нас экспортируется объект из скрипта, то он будет единым для всех импортов!**)
5. импорты добавляются в видимость самого модуля, а не в глобальную. Раньше, чтобы работать с либой, например, приходилось добавлять ее скрипты в глобальную видимость (прикреплять к объекту `window`). В принципе, можно и сейчас посмотреть, какие объекты являются глобальными. Короче говоря, все что прикреплено к объекту `window` доступно из любой точки программы:
    - console
    - конструктор `Number`, `String`, `Set`, `RegExp`...
    - некоторые функции: `encodeUrlComponent`...
6. есть еще особенности по работе с внешними либами, но мы об этом говорить не будем

`export` бывает именнованный или дефолтный. Отличия в том, что мы можем назвать дефолтный как угодно в импортируемом файле.
Именнованные импорты можно "переименовывать" с помщью `as`:
```JS
import {func1 as myFunc} from './somewhere'
```
Также можно импортировать вообще все. Видя инструкцию `import` браузер самостоятельно загрузит модуль.

## Кто такой бандл?
Бандл - статический ресурс, из которого раздается приложение

## Webpack
Webpack - статический бандлер модулей для современных JS-приложений. Работа бандлера основана на том, что он строит граф зависимостей файлов, начиная от одного или нескольких *входных точек*. И затем формирует каждый модуль проекта в один или более бандлов.<br>
Иными словами, Webpack выполняет компиляцию JS модулей и из зависимостей<br>
### До Webpack
Были распространены такие инструменты как `grunt` и `gulp`, в которых нужно было вручную обрабатывать разные источники: `css`, `imgaes`, `js`... В ходе обработки эти источники перемещались в другую папку. Но Webpack красава и делает это все сам, благодаря графу зависимостей. Также это помогает избежать бандла зависимостей, которые не используются.

## Loaders
По умолчанию, вебпак понимает только JS и JSON. Загрузчики позволяют вебпаку обрабатывать другие файлы и преобразовывать их в валидные модули.<br>
Можно воспринимать их как последовательность действий для сборки проекта. Они могут преобразовывать TS в JS, SCSS в CSS и проводить иные фокусы<br>
Лоадеры имеют 2 свойтсва:
```JS
module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js',
  },
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
};
```
Можно также создавать цепочки лоадеров: на одно правило может быть несколько загрузчиков:
```JS
module.exports = {
  module: {
    rules: [
      {
        test: /\.s*css$/,
        use: [
          { loader: 'style-loader' },
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          },
          { loader: 'sass-loader' }
        ]
      }
    ]
  }
};
```
**ОЧЕНЬ ВАЖНО, ЧТО ЦЕПОЧКА ОБРАБАТЫВАЕТСЯ В ОБРАТНОМ ПОРЯДКЕ**<br>
`test` - шаблон для файлов, `raw-loader` - лоадер для обработки
Как работает: *"Чел на вебпаке, когда встретишь файл с указанным расширением обработай его с помощью указанного лоадера, прежде чем добавить в бандл"*

## Plugins
В то время как лоадеры просто обрабатывают файлы, плагины могут выполнять целую кучу сложных операций: оптимизация, управление ресурсами, добавление переменных среды...
```JS
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
  plugins: [
    new webpack.ProgressPlugin(), // change report progress on build
    new HtmlWebpackPlugin({ template: './src/index.html' }) // добавляет bundl.js в index.html
    ],
};
```

## 1. Самая простая настройка
Просто создадим бандл из `index.js`, в котором импортится либа. Не нужна даже настройка webpack, просто кидаем `npx webpack`<br>
По умолчанию, webpack выкидывает из себя `main.js` в папку `dist`. Поэтому мы и размещаем `index.html` в dist, а также подключаем `main.js`. Входной файл должны находиться в `src/index.js` (и иметь какое-то стандартное название, но это не так важно)
**Показать, что находится в `main.js`**
### Npx vs npm
**Npm** - node packet manager. Он не выполняет никакие скрипты. Как же `npm run start`? Да, может, но чтобы он это сделал, ему нужно об этом рассказать: указать скрипт в `package.json`<br>
**npx** - node package eXecute. Как можно догадаться по `execute`, этот инструмент как раз отвечает за то, чтобы выполнять пакеты. По сути, чтобы запустить и выполнить некоторые пакеты, они нам даже не нужны на локальной машине. Но `webpack` к таким не относится, для него нужен еще и `webpack-cli` (CLI - command line instrument)
## 2. Чуть сложнее
`webpack.config.js` позволяет всяко-разно настраивать webpack. Делаем то же самое, но меняем папку на build, в которую сразу помещаем `index.html` и меняем название "выходного" скрипта на `budle.js`. Добавляем команду `"build": "webpack"` в `package.json`
## 3. Добавляем css
Это позволяет не прописывать все `css`-источники в index.html, а импортировать их в `js`.
Пободным образом можно добавлять и иные ресурсы: изображения, шрифты
## 4. HtmlWebpackPlugin
До этого мы ручками прописывали бандл, который нужно подрузить в `index.html`. А что если бандлов будет много? А что если они будут именоваться как-то интересно? Так, в webpack можно настраивать имена бандлов и дать им хеши. Зачем? Помним, что пользователь может посмотреть все ресурсы страницы. И чтобы никто не мог понять, что мы там написали, мы убираем осмысленные названия. <br>
Сделать 2 входные точки и применить к ним `[hash][id].js`. Сразу докидываем лоадеры на `sass`, `ts`, `svg`
### Мод
Каждый раз запускать `npx webpack` при любом изменении - сильная головная боль, поэтому можно:
1. `webpack --watch` - следит за файлами-зависимостями и пересобирает. Не нужны никакие доп зависимости, но нет особой конфигурации и медленоват
2. `webpack-dev-server` - поднимает сервер на локалхосте с хотрелоадом. Отличительной особенностью является ито, что он сам запускает сервер, не нужен `LiveServer`. Нужно обязательно поставить `mode = development`. По умолчанию, он `production`
### Добавляем ts
инициализируем `tsc --init`, добавляем ts-loader (можно упомянуть, что есть такой чел как `Babel`, который тоже умеет в транспиляцию TS)
### Images
Вебпак видит url в css или в коде и самостоятельно добавляет изображение в бандл.
### Inline-svg
Добавляем картинки и `inline-svg`
### css-minify, css-extract
Пара слов про оптимизацию

## 6. React && Babel
`npm i @babel/core @babel/preset-env @babel/preset-react babel-loader -D -E`
Babel - JS-транспилятор, который используется для:
1. обеспечения совместимости со старыми браузерами
  - добавление полифилов - недостающих функций, появившихся в новой версии языка. Например, `map`,`reduce`... Или новых объектов. Например, `Set`, `JSON.stingify`, `JSON.parse`
  - транспиляция в совместимую версию. Применяется в случае, если используется новое синтаксическое средство языка. Например `?` или `{...}` или `()=>{}`
2. преобразование расширений `js` в "понятный" код: `jsx`, `ts` и вот все подобное. Все, что браузер сам не понимает, бабель "переводит"
В связи с тем, что будем использовать `babel`, то `ts-loader` нам больше не понадобится, заменяем на `@babel/preset-typescript`<br>
Также добавляем `@babel/preset-react` и `@babel/preset-env`, чтобы реакт работал. Также добавляем свой шаблон, который содержит `<div id="root"></div>`


Примеры настройки:
- [Не сильный акцент спикера, Eng](https://www.youtube.com/watch?v=Gc9-7PBqOC8&ab_channel=YouGottaLoveFrontend)
- [Сильный акцент спикера, Eng]()
- [Официальный гайд](https://webpack.js.org/guides/getting-started/)